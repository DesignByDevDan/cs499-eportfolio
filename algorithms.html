<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algorithms and Data Structures Artifact</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main>
    <header>
      <h1>Algorithms and Data Structures</h1>

      <nav class="nav">
        <a href="index.html">Home</a>
        <a href="professional-self-assessment.html">Self-Assessment</a>
        <a href="code-review.html">Code Review</a>
        <a href="software-design.html">Software</a>
        <a href="algorithms.html" class="active">Algorithms</a>
        <a href="databases.html">Databases</a>
      </nav>
    </header>

    <div class="card">
      <h2>Artifact Overview</h2>
      <p>
        This page documents my <strong>Algorithms and Data Structures</strong> enhancement for CS 499 using the
        <strong>C-Cure Reporting Database</strong> artifact. The system evaluates training-based access eligibility
        and produces delta-style outputs that highlight changes requiring action or review.
      </p>
      <p>
        I selected this artifact for the algorithms category because it includes real decision logic and change-detection
        processing that must be correct, efficient, and maintainable. In a reporting and compliance context, the algorithmic
        goal is to produce accurate results while minimizing unnecessary processing and making the logic easy to validate.
      </p>
    </div>

    <div class="card">
      <h2>Original Functionality</h2>
      <p>
        The original implementation computed eligibility outputs and produced delta information by querying and comparing
        relevant datasets. It worked functionally, but there were opportunities to reduce redundant work and make the
        decision flow more deterministic and easier to reason about.
      </p>
      <p>
        In database-backed systems, algorithmic improvements often appear as reduced scans, fewer repeated joins,
        more selective filtering, and clearer evaluation steps that limit how many rows must be processed at each stage.
      </p>
    </div>

    <div class="card">
      <h2>Algorithmic Analysis: Efficiency and Trade-Offs</h2>
      <p>
        The key algorithmic challenge in this artifact is <strong>delta detection</strong>—efficiently determining what
        changed since the last evaluation and producing outputs that represent only the differences that matter.
        If delta logic is inefficient, it can require repeated full recomputation and large comparisons over the same
        data, which increases execution time and makes performance unpredictable as data volume grows.
      </p>

      <h3>Optimization Focus</h3>
      <ul>
        <li>
          <strong>Reduce redundant work:</strong> avoid repeating joins and comparisons that can be computed once and reused
          within the evaluation flow.
        </li>
        <li>
          <strong>Increase selectivity earlier:</strong> filter and constrain datasets earlier to reduce the number of rows
          processed downstream.
        </li>
        <li>
          <strong>Deterministic evaluation steps:</strong> structure logic into clear phases so the processing path is easier
          to validate and less error-prone.
        </li>
        <li>
          <strong>Balance performance and maintainability:</strong> improvements were implemented in a way that remains readable
          and auditable rather than introducing overly complex logic that is difficult to support.
        </li>
      </ul>

      <h3>Complexity Considerations (SQL Context)</h3>
      <p>
        In SQL-based systems, Big-O notation is less direct than in in-memory algorithms because execution depends on the query plan,
        indexing, and row counts. However, the same principles apply: reducing full-table scans, limiting repeated passes over data,
        and using indexed keys for comparisons improves practical performance.
      </p>
      <p>
        Conceptually, the enhancement aims to reduce behavior that resembles repeated <em>O(n × m)</em> comparisons between large sets
        by improving how joins and comparisons are structured, and by ensuring that only the necessary subsets are processed during delta detection.
      </p>
    </div>

    <div class="card">
      <h2>Enhancement Implemented: Algorithms &amp; Data Structures</h2>
      <p>
        For this enhancement, I updated the eligibility recomputation and delta detection logic to improve efficiency and clarity.
        The enhanced version emphasizes processing only what is necessary, organizing evaluation steps so that results are consistent,
        and documenting the rationale for key decisions.
      </p>

      <h3>What Improved</h3>
      <ul>
        <li><strong>More efficient delta detection</strong> by reducing unnecessary comparisons and repeated operations</li>
        <li><strong>Clearer evaluation flow</strong> that makes correctness easier to validate and maintain</li>
        <li><strong>Better performance predictability</strong> as data volumes increase</li>
        <li><strong>Improved documentation</strong> describing trade-offs and intent</li>
      </ul>
    </div>

    <div class="card">
      <h2>Evidence: Enhanced Algorithms Implementation</h2>
      <p>
        The enhanced stored procedure implementing the algorithmic improvements is available here:
      </p>
      <ul>
        <li>
          <strong>Enhanced Stored Procedure (Algorithms Version):</strong><br/>
          <a href="https://github.com/DesignByDevDan/cs499-eportfolio/blob/main/assets/code/algorithms/Algo_Enhanced_rpt.usp_RecomputeAccessDelta.sql"
             target="_blank" rel="noopener">
            Algo_Enhanced_rpt.usp_RecomputeAccessDelta.sql
          </a>
        </li>
      </ul>
    </div>

    <div class="card">
      <h2>Course Outcome Alignment</h2>
      <ol>
        <li><strong>Collaborative environments:</strong> The logic is structured and documented so peers and stakeholders can review decision flow and validate outcomes.</li>
        <li><strong>Professional communication:</strong> This narrative explains the algorithmic goals, the changes made, and the trade-offs in a way appropriate for technical and non-technical audiences.</li>
        <li><strong>Algorithmic principles and trade-offs:</strong> The enhancement improves delta detection efficiency and emphasizes correctness while balancing maintainability and performance.</li>
        <li><strong>Tools and implementation practices:</strong> Demonstrates practical engineering using SQL Server and structured development practices to deliver reporting value.</li>
        <li><strong>Security mindset:</strong> Deterministic logic and careful comparison steps reduce the risk of incorrect eligibility outcomes and support controlled, auditable reporting behavior.</li>
      </ol>
    </div>

    <div class="card">
      <h2>Reflection</h2>
      <p>
        This enhancement reinforced that algorithmic thinking applies directly to database systems. Even when working in SQL,
        performance depends on how data is filtered, joined, and compared. The biggest challenge was improving efficiency while
        keeping the logic understandable and auditable. I addressed that by organizing evaluation into clear steps and documenting
        the purpose of each phase so future updates can be made safely.
      </p>
      <p>
        The result is logic that is easier to reason about, more efficient under growth, and better aligned with professional expectations
        for correctness and maintainability in a compliance-driven reporting environment.
      </p>
    </div>

    <div class="card">
      <h2>Related Portfolio Sections</h2>
      <ul>
        <li><a href="code-review.html">Milestone One: Code Review</a></li>
        <li><a href="software-design.html">Software Design &amp; Engineering Enhancement</a></li>
        <li><a href="databases.html">Databases Enhancement</a></li>
      </ul>
    </div>

    <div class="footer">
      <p>CS 499 ePortfolio — Daniel Lowery • <a href="index.html">Home</a></p>
    </div>

  </main>
</body>
</html>
